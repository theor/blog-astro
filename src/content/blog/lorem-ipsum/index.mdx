---
title: "Demo effects using Rust and WebAssembly"
author: "theor"
type: "post"
pubDate: 2023-04-15T15:43:14.015Z
description: ""
banner: ""
tags: []
setup: |
  console.log("qwe")
---
import Run from "./_Run.astro"

I needed a reason to play with rust+wasm, and I have always loved the [demoscene](http://demoscene-the-art-of-coding.net/the-demoscene/) and its cleverness. I also wanted the result to be embeddable here on my blog made with Astro. Guess who's about to fill buffers with fire, plasma, stars and roads.

# Rust, Wasm bootstrap

The rust community has spent much time making WebAssembly a functional and efficient target, and it shows. First, the `rustc` compiler has [multiple targets](https://rustwasm.github.io/wasm-bindgen/reference/rust-targets.html) for it: we'll use the seemingly undecided `wasm32-unknown-unknown` target. The workflow that worked for me uses [wasm-pack](https://rustwasm.github.io/docs/wasm-pack/), which, in one command, handles the compilation using `cargo`, the wasm optimization/stripping using `wasm-opt` and generates the .js/.ts glue code.

I also discovered the lovely [cargo watch](https://crates.io/crates/cargo-watch) to monitor my rust folder and compile in on change, using this command:
```sh
cargo watch -s "wasm-pack build --profiling --target web -d blog-astro/src/content/blog/lorem-ipsum/_pkg --no-typescript --no-pack"
```

About arguments:
- I use `--profiling` to get function names when profiling in Chrome. Never used `--debug` ; I don't know if I got too much in the oldskool mindset, but I didn't even searched how to attach a debugger with WASM, or if it is even possible
- `--target web` outputs wasm ready for the browser. Didn't get `--target bundler` to work with Astro
- I did write my glue code in Typescript, but the ts typings that wasm-build outputs made Astro choke on a const with no value
- `--no-pack` prevents the generation of a `package.json` file, which IIUC is used when publishing npm packages. It also made Astro choke

The resulting .js files exports an `init` promise loading the actual wasm, and everything exported by the rust code.

Rust exports are made using `wasm-bindgen` :

```rust
#[wasm_bindgen]
pub struct Plasma { /* ... */ }

#[wasm_bindgen]
impl Plasma {
    #[wasm_bindgen(constructor)]
    pub fn new(w: usize, h: usize) -> Self { /* ... */ }

    pub fn update(&mut self,t: f32) { /* ... */ }
}
```


```ts
import init, { Plasma, StatefulFire, Stars, Roads2,  } from "./_pkg/sample_rust";

await init();
const p = new Plasma(WIDTH, HEIGHT);
p.update(time);
```


I added controls using [TweakPane](https://cocopon.github.io/tweakpane/), a great js lib for controls Ã  la datgui/imgui. Then it's just a matter of filling an HTML Canvas using rust code - more on that in the [Wasm interop optimization section](#todays-rabbit-hole--wasm-interop-optimization)

# Plasma effect
<Run data-sample="Plasma" />
The plasma effect is typical of demo effects: trivial to do today with a GPU, impressive when it was written on a CPU, often without a floating point unit. Look at this Amstrad demo:

<YouTube id="cEFDKup7il8"/>


The gist of it is to compute a color for each pixel using some combination of trigonometric functions ; usually, the function returns a valueused as an index in a pre-computed palette. An indexed palette used to be a requirement - the above Amstrad CPC had at best at 16 colors palette out of 27, in Mode 0 (160x200 pixels) before using any of the typical palette-expanding tricks of the time. However palette indexing is still more performant today, and gives other opportunities like [palette shifting (more details in my esp32/demoscene article)](/esp32-love-notes-demoscene/#tooling-for-palette-indexed-bitmaps).

Let's start with simple concentric circles and a grey scale palette. The palette is a simple lerp outputting ABGR colors as `u32`, as the HTML canvas expects that format:

```rust

fn col32(r: u8, g: u8, b: u8) -> u32 {
    255 << 24 | (b as u32) << 16 | (g as u32) << 8 | (r as u32)
}

const PALETTE_SIZE: usize = 256;
let mut palette: Vec<u32> = vec![0; PALETTE_SIZE];

for i in 0..PALETTE_SIZE {
    let f = i as f32 / PALETTE_SIZE as f32;

    // color_sys crate
    let c = rgb(i as u8, i as u8, i as u8);
    palette[i] = c;
}
```

Next

```rust
for y in 0..self.h {
    for x in 0..self.w {
        // position as ratios, in the [0,1] range
        let fx = x as f32 / (self.w - 1) as f32;
        let fy = y as f32 / (self.h - 1) as f32;

        // palette index
        let v = (
            vec2(fx - 0.5, fy - 0.5)
            * 16.0
        ).length().sin();

        // buffer index
        let i = y * self.w + x;
        b[i] = self.palette[
            remap(
                v,
                -1.0..=1.0,
                0.0..=255.0)
            as usize % 256];
    }
}
```


<Run data-sample="Plasma" data-static="true" data-step="FixedCircle" data-palette="Greyscale" data-disablepane="true"/>
<Run data-sample="Plasma" data-step="ShiftedCircle" data-palette="Greyscale" />
<Run data-sample="Plasma" data-step="ShiftedCircle" data-palette="GreyscaleLooped"/>
<Run data-sample="Plasma" data-step="ShiftedCircle" data-palette="Colors"/>
<Run data-sample="Plasma" data-step="Perturbation" data-palette="Colors"/>
<Run data-sample="Plasma" data-palette="ColorsStepped"/>


```rust
#[wasm_bindgen]
pub struct Plasma {
    w: usize,
    h: usize,
    palette: Vec<u32>,
}

#[wasm_bindgen]
impl Plasma {
    #[wasm_bindgen(constructor)]
    pub fn new(w: usize, h: usize) -> Self {
        let mut palette: Vec<u32> = vec![0; 256];
        for i in 0..palette.len() {
            let f = i as f32 / palette.len() as f32;
            let c = Rgb::from(Hsl::from((
                lerp(203.0..=31.0, f),
                82.0,
                ((f+0.5).powi(2)*100.0).clamp(10.0, 60.0)
            )));
            palette[i] = col32(
                c.red().min(255.0) as u8,
                c.green().min(255.0) as u8,
                c.blue().min(255.0) as u8,
            );
        }

        Self { w, h, palette }
    }

    pub fn update(&mut self, b: &mut [u32], time: f32) {

        let a = vec2(self.w as f32 / self.h as f32, 1.0);
        for y in 0..self.h {
            for x in 0..self.w {
                let fx = x as f32 / self.w as f32;
                let fy = y as f32 / self.h as f32;

                let c = vec2(fx, fy) * a * 8.0 + vec2(time * 0.3,time * 0.3);
                let k = 0.1 + (c.y + (0.148 - time).sin()).cos() + 2.4 * time;
                let w = 0.9 + (c.x + (0.628 + time).cos()).sin() - 0.7 * time;
                let d = c.length();
                let s = 7.0 * (d+w).cos() * (k+w).sin();
                let i = y * self.w + x;
                let cv = s + vec3(0.2, 0.5, 0.9);
                b[i] = col32f(cv.x,cv.y, cv.z);
                let c = self.palette[((s.cos() * 0.5 + 0.5) * 255.0) as usize % 256];
                b[i] = c;
            }
        }
    }
}
```


The real bottleneck, however, is the massive amount of `sin/cos` calls. I tried to implement a precomputed look-up table for the trigonometry as [we used to](https://namoseley.wordpress.com/2015/07/26/sincos-generation-using-table-lookup-and-iterpolation/) but Rust's own trig is still twice as fast. Maybe I'll investigate, there's a potential article here...

# Fire effect

<Run id="asd3" data-sample="firestate" data-message="wwwww"/>



[Fabien Sanglard](https://fabiensanglard.net/doom_fire_psx/index.html)

# Stars

<Run data-sample="Stars" />

# Outrun 3d roads

<Run data-sample="Roads"/>

[Lou's pseudo 3d page](http://www.extentofthejam.com/pseudo/)

# Today's rabbit hole : Wasm interop optimization

# Another rabbit hole : macros and reflection 
